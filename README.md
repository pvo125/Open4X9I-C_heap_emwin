# Open4X9I-C_heap_emwin
Плата WaveShare Open4X9I-C. MCU STM32F429IGT6. Дисплей 480*272 шина RGB 24 bits. Touch контроллер XPT2046 подключен по SPI2 1.4 MHz.
* Написан драйвер для работы с мышью PS/2.
Тактовый сигнал (clk) от PS/2 соединен с PA7 и тактирует таймер TIM3. TIM3 увеличивает значение CNT по спаду сигнала clk каждый раз генерируя прерывание TGI. В обработчике если установлен TIF вызывается PS2_Mouse_ISR() в которой происходит считывание уровня на выводе PC1 data таким образом побитно принимается посылка от мыши и релизован интерфейс PS/2. Когда CNT переполняется (ARR=10) TIM3 генерит прерывание UI с установкой флага UIF в обработчике запускается функция которая декодирует принятый пакет(PS2_Mouse_CheckScancode(scancode)).Передача делается так. MCU делает запрос (PA7 PC1 переводятся в GP output mode) clk=0--пауза(110мкс)--data=0--clk=1. Затем вывод PA7 вновь делается AF подключенным к TIM3. После этого PS/2 начинает формировать такты на clk 
а MCU в прерывании от TIM3 TGI при режиме TX_MODE формирует ножкой (PC1 GPIO) ноль или единицу каждый раз сдвигая на бит вправо байт который передаёт. TIM3 во время передачи увеличивается на 1 и при переполнении (ARR=10) происходит прерывание в нем меняется режим для последующего приема PS2_MOUSE_VAR.mode=RX_MODE. Байт отправлен.
* Модуль LTDC настроен на вывод 2 слоев(Layer_0 Layer_1). В нижнем слое(Layer_0) выводятся окна и виджеты-иконки. В верхнем слое(Layer_1)
виджеты-иконки alarm_a alarm_b, время и дата, виджет progbar(индикация использования памяти) а также виджет slider который переключает нижние окна. LTDC работает в режиме ARGB8888 (32 бита).
* Для каждого слоя настроена "тройная буфферизация" для перерисовки 2 окон нижнего слоя и 1 "transparent" окна верхнего слоя. Для этого есть API emWin GUI_MULTIBUF_BeginEx(1)-копирует "front buffer" в "back buffer" для выполнения всех drawing операций. GUI_MULTIBUF_EndEx(1) вызывает callback драйвера дисплея с cmd LCD_X_SHOWBUFFER и переключает вывод кадра LCD на "back buffer" который уже готов и нарисован. GUI_MULTIBUF_EndEx() GUI_MULTIBUF_BeginEx() которые вызываются в callback функции (WM_PRE_PAINT WM_POST_PAINT). 
    * Для Layer_0 0xD0000000-0xD017E7FF(480 * 272 * 4(байта/пиксел) * 3(буффера)=522240*3(буфера)=1566720 байт или 0x17E800)
    * Для Layer_1 0xD017E800-0xD02FCFFF
* Для связи с PC и загрузки бинарника в буфер SDRAM (для последующего обновления MCU по сети CAN) настроен USART1(через переходник USB-USART PL2303 который распаян на плате). USART1 настроен на работу через DMA2 и спользуется прерывание по IDLE для определения конца посылки произвольной длинны. DMA2_Stream2-RX  DMA2_Stream7-TX. 
Прием данных идет след. образом: DMA2_Stream2 настроен на прием и включен. Принимаемые байты DMA2 "складывает" в RXBuffer после прихода последнего байта линия RX переходит с сост. idle и USART1 генерит прерывание в котором если принимаем команду(uart_data_message==0) то выставляем флаг нового сообщения uart_newmessage=1. Если примаем данные(uart_data_message==1) выставляем флаг uart_get_data=1(если посылка длиннее 16 байт) или  флаг uart_get_size=1(если посылка меньше 16 байт значит пришли данные с размером бинарника).
Передача идет так: Выключаем прерывание по idle state для USART1 (HAL_UART_DISABLE_IT(&huart1, UART_IT_IDLE)).Настраиваем DMA2_Stream7 на передачу определенного количества байт через USART1 и запускаем. После того как DMA2 отправит все байты срабатывает прерывание в котором очищается флаг готовности DMA (HAL_DMA_CLEAR_FLAG(&hdma2,DMA_FLAG_TCIF3_7)) и разрешается прерывание по idle state для USART1(HAL_UART_ENABLE_IT(&huart1, UART_IT_IDLE)) для последующего приема данных.
Сам протокол обмена между STM32 и PC примерно такой:
* PC отправляет строчку "hello st/n"
* STM32 шлет в ответ строчку "get size"
* PC присылает размер бинарника в виде символьной строки. (Размер 216432 байта придет в виде последовательности 6 байт 32 31 36 34 33 32) 
* STM32 высчитывает размер и сохраняет его в глоб. переменной  size и шлет строку "get data"
* PC начинает слать сам файл бинарника порциями по 10000(можно настроить в Qt любую порцию до 65535 байт за раз) байт а DMA2_Stream2 складывать их в SDRAM с адреса 0xD040 0000 и после каждой порции срабатывает UART_IT_IDLE прерывание в котором выставляется флаг uart_get_data для отправки на PC запроса ("get data") на след. порцию данных. Когда size-transaction==0 ставится флаг uart_end_transaction и считается crc32 функцией crc=crc32_check((const uint8_t *)0xd0400000,(size-4)); Если подсчитанная сумма совпадает с пришедшим вместе с данными значением по адресу if(crc==*(uint32_t*)(0xd0400000+size-4)) то STM32 шлет в ответ PC "crc OK!" и процесс передачи прекращается. Если не совпадает то шлет "crc error!"
* Написан диалог для отображения MCU в сети CAN(типа сетевого окружения) и для каждого узла доступно окно в котором отображаются некоторые параметры этого MCU. Эти параметры каждый контроллер в сети отправляет по запросам от данной платы.
Запрос GET_NETNAME Id=0x088 - широковещательтный(на всех MCU настроен фильтр для этого сообщения)  отправляется каждые 2 секунды для всех устройств в данный момент подключенных к сети. Служит для построения и обновления раз в 2 секунды списка устройств сети в дилоге CANNetExplore().При нажатии на узел открывается окно и диалог CANNodeDialog(uint8_t index) для каждого узла в сети свое окно и диалог. Для каждого такого окна создается таймер на 1 сек и каждый раз при истечении таймера окно шлет запрос GET_RTC (Id=0x080) GET_TIMER_DATA(0x082). При получении CAN сообщений (0xX80 или 0xX82) в обработчике прерывания для соотв. FIFO сначала читается индекс узла от которого пришло сообщение index=CAN_Data_RX[0].Data[0] затем в локальную переменную CANNode_TypeDef CANNode читаем всю структуру с окна соотв. узла. Меняем только те поля для которых пришло сообщение и снова сохраняем всю структуру в окне. При получении сообщений с (Id=0xX88) в переменную netname_index=CAN_Data_RX[1].Data[0] и ставится флаг new_node=1 а в функции  _Browse_CANNet() добавляется Item в TREEVIEW.    
Для рассылки бинарника по CAN сети и обновления MCU работает такая схема.
* 
